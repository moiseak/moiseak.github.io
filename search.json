[{"title":"CS61A(一)","url":"/posts/4eba9996.html","content":"Recursive Leap of Faith\n\n若要让我回忆在CS61A-Python部分最印象深刻的知识是什么, 那一定是 Recursive Leap of Faith . 我至今仍清楚的记得那个下午我用List Comprehensions and Tree Recursion随手用两行代码就解决一个问题后, 回过神来: “我也…变得稍微有点厉害了吧.”\n\n请确保你已经有Python关于Functions, Control, Sequences and OOP的基础知识\n入门\n为什么叫做\"信仰之跃\"? 我认为是: 信任你的递归函数, 你让它做什么, 它就一定会做到, 无论过程如何.\n举个简单的例子:\n1.sum_digits\n现在要求编写一个计算一个正整数所有位上的数字的和, 比如123所有位的和就是1+2+3=6.\n那现在想一想, 你希望你编写的函数做到什么?\n我们直接定义我们编写的函数能够计算一个正整数所有位上的数字的和, 但肯定不能直接把这个正整数放进去, 所以一个很自然的想法出现了:\n用我们定义的函数计算前面n-1位数字的和再加上最后一位不就可以了:\nsum_digits(all_but_last) + last\n但我们很轻易就能发现这里还有一种特殊情况: 当这个正整数是个位数的时候, 不需要计算, 直接返回就可以了.\n于是我们可以把完整的代码写出来了:\ndef sum_digits(n):    \"\"\"Return the sum of the digits of positive integer n.\"\"\"    if n &lt; 10:                                      #特殊情况        return n    else:        all_but_last, last = n // 10, n % 10        return sum_digits(all_but_last) + last      #不用担心sum_digits(all_but_last)怎么得到答案, 这就是它的定义\n如果你干过用人脑压栈的蠢事, 对这个方法的感触会更深\n继续:\n2.double_eights\n编写一个函数判断一个正整数是否含两个有相邻的数字’8’, 如88, 1889, 1881111都return True.\n同样地相信我们的函数, 第一步可以先判断个位和十位有没有连续的’8’, 如果有直接return True, 如果没有, 个位就被排除了.\n我们又注意到如果这个正整数只有两位数, 那么我们判断完个位和十位不符合条件后就可以直接return False了.\n接下来就可以用我们定义的函数, 来判断除了最后一位的前n-1位有没有相邻的’8’.\n通过上面的思考, 翻译成Python完整代码如下:\ndef double_eights(n):    last, second_last = n % 10, n // 10 % 10        if last == 8 and second_last == 8:              #判断个位和十位        return True    elif n &lt; 100:                                   #两位数不符合上述条件直接返回, 不进递归        return False    return double_eights(n // 10)                   #个位被排除了\n通过上面两个例子, 我们可以稍微总结一下了, 写递归函数一般由三部分组成:\n1. Base case(s), 即特殊情况(可能不止一个).\n2. Recursive call, 即递归调用.\n3. Recombination, 即对递归结果的使用.\n同时, 我们对这个所谓的\"特殊情况\"可以再讨论一下, 它是否可以看作递归的截止条件? 满足该条件即结束本层递归, 返回上层递归.\n初级\n请尽量先自己想一想\n3.make_onion\n编写一个函数make_onion, 该函数接受两个单参数函数 f 和 g. 它return一个函数can_reach, 该函数接受：x、y 和 limit三个参数.\n如果可以使用最多 limit 次对函数 f 和 g 的调用从 x 到达 y，则return True，否则return False.\n例如，如果调用 f 值就加 1 ,调用 g 值就加倍，则可以通过四次调用从 5 到达 25：f(g(g(f(5)))). 即can_reach(5, 25, 4) return True.\n因为有两个函数, 所以用or代表两个方向, 任何一个方向成功就返回True, 同时注意我们调用了一次 f or g ,所以limit次数记得减一.\n一个函数不直接返回答案, 而是返回另一个函数来辅助得到答案, 那么这个返回函数就叫做辅助函数.\ndef make_onion(f, g):    \"\"\"Return a function can_reach(x, y, limit) that returns    whether some call expression containing only f, g, and x with    up to limit calls will give the result y.\"\"\"    def can_reach(x, y, limit):        if limit &lt; 0:            return False        elif x == y:            return True                 #两个 base cases.        else:            return can_reach(f(x), y, limit - 1) or can_reach(g(x), y, limit - 1)    return can_reach\n4.count_partitions\n给定正整数 n 和部分最大大小 m，n 的划分数是将 n 表示为不超过 m 的正整数部分的和的方式数目，每种和按递增顺序排列。\n例子：使用不超过 4 的部分划分 6 的方式有 9 种：\n6 = 2 + 4\n6 = 1 + 1 + 4\n6 = 3 + 3\n6 = 1 + 2 + 3\n6 = 1 + 1 + 1 + 3\n6 = 2 + 2 + 2\n6 = 1 + 1 + 2 + 2\n6 = 1 + 1 + 1 + 1 + 2\n6 = 1 + 1 + 1 + 1 + 1 + 1\n定义函数 count_partitions(n, m)，返回使用不超过 m 的部分划分 n 的不同方式数目。\n我们要划分一个数 n，且划分中的每个部分都不超过 m。这个问题可以通过递归思想分成两种情况来考虑：\n\n\n包含至少一个 m：\n在这种情况下，划分中有一部分是 m。\n由于已经使用了一个 m，剩下的部分实际上是在划分 n - m 的问题，并且这些部分仍然不能超过 m。\n例如，如果我们要划分 6，且最大部分为 4，则可以先取出一个 4，剩下的问题就是划分 6 - 4 = 2，且部分最大为 4。\n因此，划分 n 使用不超过 m 的部分，其中包含 m 的情况，相当于 划分 n - m 使用不超过 m 的方式数。\n\n\n不包含 m：\n在这种情况下，划分中的所有部分都必须小于 m，这意味着我们是在划分 n，使用的部分最大只能是 m - 1。\n例如，划分 6，且不包含 4，意味着最大部分只能是 3 或更小。所以这相当于“划分 6，且最大部分为 3”的问题。\n因此，划分 n 使用不超过 m 的部分，其中不包含 m 的情况相当于 划分 n 使用不超过 m - 1 的方式数。\n\n\ncount_partitions(n, m) = count_partitions(n - m, m) + count_partitions(n, m - 1)\nBase cases是什么?\n划分 0 的方式只有一种：不包含任何部分；\n对负数 n 划分的方式为 0；\n对 n &gt; 0 使用大小为 0 或更小的部分划分的方式为 0。\n实现如下:\ndef count_partitions(n, m):    \"\"\"Count the ways to partition n using parts up to m.\"\"\"    if n == 0:        return 1    elif n &lt; 0:        return 0    elif m == 0:        return 0    else:        return count_partitions(n-m, m) + count_partitions(n, m-1)\n下面会涉及几种数据结构, 如果你需要复习,请点击\n中级\n5.berry_finder\n校园里的松鼠需要你的帮助！校园里有很多树，松鼠想知道哪些树上有浆果。定义一个名为berry_finder的函数，该函数接收一棵树作为输入，如果树中有一个节点的值为 ‘berry’，则返回 True，否则返回 False.\n回忆一下我们上面讲到的.对于一棵树, 由于它的分支是一个列表, 所以我们有特殊的递归使用:\nfor b in branches(t):    berry_finder(b)\n那么这道题, 我们对每个子树分别进行搜索就能得到答案了:\nif label(t) == 'berry':                     #不要忘记检查label, 同时这个语句也是递归的截止条件        return True    for b in branches(t):                   #遍历子树        if berry_finder(b):                 #判断每个子树是否符合条件            return True    return False\n6.max_path_sum\n编写一个函数，接收一棵树作为输入，并返回从树根到任意叶节点路径上节点值的最大和。根到叶节点的路径是指从根节点开始，经过一系列节点到达某个叶节点的节点序列。可以假设树中的所有节点标签都是正数。\n寻找最大和可以使用max函数, 参数为各个子树的最大和.\n同样的, 对于这种树的题目我们可以直接把子树全塞我们定义的函数中, 再加上base cases:\ndef max_path_sum(t):    \"\"\"Return the maximum root-to-leaf path sum of a tree.    &gt;&gt;&gt; t = tree(1, [tree(5, [tree(1), tree(3)]), tree(10)])    &gt;&gt;&gt; max_path_sum(t) # 1, 10    11    &gt;&gt;&gt; t2 = tree(5, [tree(4, [tree(1), tree(3)]), tree(2, [tree(10), tree(3)])])    &gt;&gt;&gt; max_path_sum(t2) # 5, 2, 10    17    \"\"\"    # Non-list comprehension solution    if is_leaf(t):        return label(t)    highest_sum = 0    for b in branches(t):        highest_sum = max(max_path_sum(b), highest_sum)    return label(t) + highest_sum    # List comprehension solution    if is_leaf(t):      return label(t)    else:      return label(t) + max([max_path_sum(b) for b in branches(t)])\n7.add_d_leaves\n实现add_d_leaves函数，该函数接收一个 Tree 实例 t 和一个数字 v。\n我们定义树 t 中某个节点的深度为从根节点到该节点之间边的数量。因此，根节点的深度为 0。\n对于树中的每个节点，你应该根据节点的深度 d 添加 d 个叶子节点。每个添加的叶子节点的标签都应该为 v。如果某个节点已经有了分支，应该将这些叶子添加到分支列表的末尾。\n例如，你需要在深度为 1 的每个节点上添加 1 个标签为 v 的叶子，在深度为 2 的每个节点上添加 2 个标签为 v 的叶子，依此类推。\n同样的遍历每个子树, 并且对每个子树都进行添加叶子.\n函数里面我们要让他干什么呢? 根据节点的深度来添加叶子, 所以我们还需要一个辅助函数来记录节点的深度.\nt.branches.extend([Tree(v) for _ in range(d)])\nfor b in t.branches:    add_leaves(b, d + 1)\n还要注意我们要在遍历之后再添加叶子, 否则后面的遍历会把新加入的叶子一起遍历, 这不符合我们的要求\n结合:\ndef add_d_leaves(t, v):    \"\"\"Add d leaves containing v to each node at every depth d.\"\"\"    def add_leaves(t, d):        for b in t.branches:            add_leaves(b, d + 1)        t.branches.extend([Tree(v) for _ in range(d)])     add_leaves(t, 0)\n8.level_mutation_link\n给定一棵树 t 和一个由单参数函数组成的链表 funcs，编写一个函数，通过使用 funcs 中对应深度的函数，修改树 t 中各节点的标签。例如：\n根节点（深度 0）的标签将使用 funcs 中深度 0 对应的函数来修改（即 funcs.first）。\n树中第一层的节点标签将使用 funcs 中深度 1 对应的函数来修改（即 funcs.rest.first），依此类推。\nfuncs 中的每个函数都会接收一个标签值，并返回一个有效的标签值。\n如果一个节点是叶节点，并且 funcs 中还有未使用的函数，这些剩余的函数应该按顺序依次应用于叶节点的标签。如果 funcs 为空，则树应保持不变。\n请参考 doctests 示例进行理解。\ndef level_mutation_link(t, funcs):\t\"\"\"Mutates t using the functions in the linked list funcs.\t&gt;&gt;&gt; t = Tree(1, [Tree(2, [Tree(3)])])\t&gt;&gt;&gt; funcs = Link(lambda x: x + 1, Link(lambda y: y * 5, Link(lambda z: z ** 2)))\t&gt;&gt;&gt; level_mutation_link(t, funcs)\t&gt;&gt;&gt; t    # At level 0, apply x + 1; at level 1, apply y * 5; at level 2 (leaf), apply z ** 2\tTree(2, [Tree(10, [Tree(9)])])\t&gt;&gt;&gt; t2 = Tree(1, [Tree(2), Tree(3, [Tree(4)])])\t&gt;&gt;&gt; level_mutation_link(t2, funcs)\t&gt;&gt;&gt; t2    # Level 0: 1+1=2; Level 1: 2*5=10 =&gt; 10**2 = 100, 3*5=15; Level 2 (leaf): 4**2=16\tTree(2, [Tree(100), Tree(15, [Tree(16)])])\t&gt;&gt;&gt; t3 = Tree(1, [Tree(2)])\t&gt;&gt;&gt; level_mutation_link(t3, funcs)\t&gt;&gt;&gt; t3    # Level 0: 1+1=2; Level 1: 2*5=10; no further levels, so apply remaining z ** 2: 10**2=100\tTree(2, [Tree(100)])\t\"\"\"\tif funcs is Link.empty:                         #为空链表则直接返回\t\treturn\tt.label = funcs.first(t.label)\tremaining = funcs.rest\tif t.is_leaf() and remaining is not Link.empty:         #剩余的函数全部应用\t\twhile remaining is not Link.empty:\t\t\tt.label = remaining.first(t.label)\t\t\tremaining = remaining.rest\tfor b in t.branches:                                #正常遍历\t\tlevel_mutation_link(b, remaining)\n参考资料:\n[1]: https://www.composingprograms.com/\n[2]: https://cs61a.org/\n[3]: https://composingprograms.netlify.app/\n[4]: https://www.youtube.com/watch?v=31EDjrN1x5k&amp;list=PL6BsET-8jgYUUBHIgUAqjrMUoPCGQcYdl\n[5]: https://www.youtube.com/watch?v=sflkoII6Sgs&amp;list=PLx38hZJ5RLZfbxxUweflX7WTodft__azP&amp;index=2\n","categories":["CS61A"],"tags":["算法","Python"]},{"title":"CS61A(二)","url":"/posts/91a50de5.html","content":"Scheme入门\n摆\n","categories":["CS61A"],"tags":["Python","Scheme"]},{"title":"CS61B-21SP-Project0","url":"/posts/7fe63c41.html","content":"关于这个项目,我们要完成的是一个2048游戏,我们有四个任务需要完成.\n这四个任务的难度算是递增吧,他说最后一个的推荐时间是三到十个小时,其实是用不了那么多的,不用害怕.\nemptySpaceExists\n我们先来看第一个, 我们要完成的是只要这个棋盘上有一个空格,就返回true.\n我们无法直接访问棋盘上方块的值,需要用刚才的.value().\n所以这个思路就很明确吧,遍历一遍棋盘就可以了.\npublic static boolean emptySpaceExists(Board b) {    int size = b.size();    for (int i = 0; i &lt; size; i++) {        for (int j = 0; j &lt; size; j++) {            //return true if any of the tiles are null.            if (b.tile(i, j) == null) {                return true;            }        }    }    return false;}\nmaxTileExists\n然后看第二个, 这个要实现的是如果方块的值达到最大值返回true.\n这个和第一个一样,遍历就可以了,注意.value()不能对null使用.\npublic static boolean maxTileExists(Board b) {    int size = b.size();    for (int i = 0; i &lt; size; i++) {        for (int j = 0; j &lt; size; j++) {            if (b.tile(i, j) != null) {                if (b.tile(i, j).value() == MAX_PIECE) {                    return true;                }            }        }    }    return false;}\natLeastOneMoveExists\n第三个是判断这个棋盘还能不能动了,如果没有空位或者没有能合并的两个方块就是不能动了.\n首先有没有空位我们可以直接用我们写的第一个方法判断.\n然后是不是继续遍历呀,不过我们可以想一想,如果每个方块都判断一遍上下左右不仅特别麻烦,还会重复比较很多次.\n而且不是每个方块都有上下左右的,靠边的我们还要特别处理,想一想就很麻烦吧,那应该怎么办呢?\n我们需要对他这个棋盘的布局熟悉一下,棋盘以左下角为(0,0),注意第一个坐标表示列,第二个表示行.\n那么我们是不是判断每个方块的上边和右边有没有相同的值就可以了,这样就能覆盖所有的方块了.\npublic static boolean atLeastOneMoveExists(Board b) {    // TODO: Fill in this function.    if (emptySpaceExists(b)) {        return true;    }    int size = b.size();    for (int i = 0; i &lt; size; i++) {        for (int j = 0; j &lt; size; j++) {            //whether there is the same value above.            if (j &lt; size - 1 &amp;&amp; b.tile(i, j).value() == b.tile(i, j + 1).value()) {                return true;            }            //whether there is the same value right.            if (i &lt; size - 1 &amp;&amp; b.tile(i, j).value() == b.tile(i + 1, j).value()) {                return true;            }        }    }    return false;}\ntilt\n最后一个是完成这个游戏的部分逻辑,当我们摁上下左右键的时候改变棋盘,我们只需要负责判断方块是否合并再移动到它应该在的位置.并且还要积分.\n我们目前不用考虑那么多,先只考虑摁上键的情况.\n如果一个方块没有合并,那是不是可以直接滑就行了. 另外就是每个方块每个回合只能使用一次move,也就是要一次到位. 那么如果一列有两个无法合并的应该怎么移动?从上到下依次排列吧,也就是说,他移动的顺序是先考虑上面的,再考虑下面的.合并的顺序也是这样.\n为什么这么做呢?根据游戏规则,如果有三个相同的方块挨着,先合并上面两个,比如一列是333x,合并结果就是63xy.\n所以我们遍历的顺序需要改变一下,需要从倒数第二列开始(因为最上方是动不了的),从上到下遍历,这样才能保证合并的顺序是对的.\n如果上方为空,就可以移动上去,如果上方值相同也可以移动上去合并,如果都不行,那就动不了. 不要忘了每个方块每个回合只能合并一次,所以我们还要记录这个方块有没有合并过.\n还要更新一下分数,move合并的话会返回ture,可以用这个来判断是否加分.\n最后就是加上他给的辅助转换视角的函数.\npublic boolean tilt(Side side) {    boolean changed;    changed = false;    // TODO: Modify this.board (and perhaps this.score) to account    // for the tilt to the Side SIDE. If the board changed, set the    // changed local variable to true.    int size = board.size();    //record whether have been merged.    board.setViewingPerspective(side);    for (int i = 0; i &lt; size; i++) {        boolean[] merged = new boolean[size];        for (int j = size - 2; j &gt;= 0; j--) {            Tile t = board.tile(i, j);            if (t == null) {                continue;            }            //find target.            int target = j;            for (int c = j + 1; c &lt; size; c++) {                if (board.tile(i, c) == null) {                    target = c;                } else if (board.tile(i, c).value() == t.value() &amp;&amp; !merged[c]) {                    target = c;                    merged[c] = true;                } else {                    break;                }            }            //update score            if (target != j) {                if (board.move(i, target, t)) {                    score += t.value() * 2;                }            }            changed = true;        }    }    if (changed) {        setChanged();    }    board.setViewingPerspective(Side.NORTH);    return changed;}\n这个项目还是比较基础的,主要就是熟悉一下Java的写法,毕竟和Python还是有区别的.\n","categories":["CS61B"],"tags":["Java"]},{"title":"CS61B-21SP-Project1","url":"/posts/8e10cd7.html","content":"这个proj还是有难度的,不过一个proj就能融合Java的大部分知识,很值得一做.\ndeque\nLinkedListDeque\n注意sentinel的使用,目的是避免链表为空.\npackage deque;import java.util.Iterator;/** * @author Moiads */public class LinkedListDeque&lt;T&gt; implements Deque&lt;T&gt;, Iterable&lt;T&gt; {    private final ListNode&lt;T&gt; sentinel;    private int size;    private static class ListNode&lt;T&gt; {        T val;        ListNode&lt;T&gt; next;        ListNode&lt;T&gt; prev;        ListNode(T x) {            val = x;            next = null;            prev = null;        }    }    public LinkedListDeque() {        sentinel = new ListNode&lt;&gt;(null);        sentinel.next = sentinel;        sentinel.prev = sentinel;        size = 0;    }    private class LinkedListIterator implements Iterator&lt;T&gt; {        private ListNode&lt;T&gt; current;        LinkedListIterator() {            current = sentinel;        }        @Override        public boolean hasNext() {            return current.next.val != null;        }        @Override        public T next() {            T ret = current.next.val;            current = current.next;            return ret;        }    }    @Override    public Iterator&lt;T&gt; iterator() {        return new LinkedListIterator();    }    @Override    public boolean equals(Object o) {        if (o instanceof Deque) {            Deque&lt;T&gt; other = (Deque&lt;T&gt;) o;            if (this.size() != other.size()) {                return false;            }            for (int i = 0; i &lt; size(); i++) {                if (!(this.get(i).equals(other.get(i)))) {                    return false;                }            }            return true;        }        return false;    }    @Override    public void addFirst(T x) {        ListNode&lt;T&gt; newNode = new ListNode&lt;&gt;(x);        sentinel.next.prev = newNode;        newNode.next = sentinel.next;        sentinel.next = newNode;        newNode.prev = sentinel;        size += 1;    }    @Override    public void addLast(T x) {        ListNode&lt;T&gt; newNode = new ListNode&lt;&gt;(x);        sentinel.prev.next = newNode;        newNode.prev = sentinel.prev;        sentinel.prev = newNode;        newNode.next = sentinel;        size += 1;    }    @Override    public int size() {        return size;    }    @Override    public void printDeque() {        ListNode&lt;T&gt; current = sentinel.next;        while (current != sentinel) {            System.out.print(current.val + \" \");            current = current.next;        }        System.out.println();    }    @Override    public T removeFirst() {        if (size == 0) {            return null;        }        T removeValue = sentinel.next.val;        sentinel.next = sentinel.next.next;        sentinel.next.prev = sentinel;        size -= 1;        return removeValue;    }    @Override    public T removeLast() {        if (size == 0) {            return null;        }        T removeValue = sentinel.prev.val;        sentinel.prev = sentinel.prev.prev;        sentinel.prev.next = sentinel;        size -= 1;        return removeValue;    }    @Override    public T get(int index) {        ListNode&lt;T&gt; current = sentinel.next;        for (int i = 0; i &lt; index; i++) {            current = current.next;        }        return current.val;    }    public T getRecursive(int index) {        return getRecursiveHelper(sentinel.next, index);    }    private T getRecursiveHelper(ListNode&lt;T&gt; node, int index) {        if (index == 0) {            return node.val;        } else {            return getRecursiveHelper(node.next, index - 1);        }    }}\nArrayDeque\n难点是循环数组的实现以及resize.\npackage deque;import java.util.Iterator;/** * @author Moiads */public class ArrayDeque&lt;T&gt; implements Deque&lt;T&gt;, Iterable&lt;T&gt; {    private T[] array;    private int size;    private int nextlast;    private int nextfirst;    public ArrayDeque() {        array = (T[]) new Object[8];        size = 0;        nextlast = 1;        nextfirst = 0;    }    private class ArrayDequeIterator implements Iterator&lt;T&gt; {        private int current;        ArrayDequeIterator() {            current = 0;        }        @Override        public boolean hasNext() {            return current &lt; size();        }        @Override        public T next() {            T returnValue = get(current);            current++;            return returnValue;        }    }    @Override    public Iterator&lt;T&gt; iterator() {        return new ArrayDequeIterator();    }    @Override    public boolean equals(Object o) {        if (o instanceof Deque) {            Deque&lt;T&gt; other = (Deque&lt;T&gt;) o;            if (this.size() != other.size()) {                return false;            }            for (int i = 0; i &lt; size(); i++) {                if (!(this.get(i).equals(other.get(i)))) {                    return false;                }            }            return true;        }        return false;    }    @Override    public int size() {        return size;    }    private T[] resize(int newSize) {        T[] newArray = (T[]) new Object[newSize];        for (int i = 0; i &lt; size; i++) {            newArray[i] = get(i);        }        nextfirst = newArray.length - 1;        nextlast = size;        return newArray;    }    @Override    public void addFirst(T item) {        if (size == array.length) {            array = resize(size * 2);        }        array[nextfirst] = item;        nextfirst = (nextfirst - 1 + array.length) % array.length;        size++;    }    @Override    public void addLast(T item) {        if (size == array.length) {            array = resize(size * 2);        }        array[nextlast] = item;        nextlast = (nextlast + 1) % array.length;        size++;    }    @Override    public T removeFirst() {        if (isEmpty()) {            return null;        }        if (size &lt; array.length / 4 &amp;&amp; size &gt; 8) {            array = resize(array.length / 2);        }        size--;        nextfirst = (nextfirst + 1) % array.length;        T temp = array[nextfirst];        array[nextfirst] = null;        return temp;    }    @Override    public T removeLast() {        if (isEmpty()) {            return null;        }        if (size &lt; array.length / 4 &amp;&amp; size &gt; 8) {            array = resize(array.length / 2);        }        size--;        nextlast = (nextlast - 1 + array.length) % array.length;        T temp = array[nextlast];        array[nextlast] = null;        return temp;    }    @Override    public T get(int index) {        int in = (nextfirst + 1 + index) % array.length;        return array[in];    }    @Override    public void printDeque() {        for (int i = 0; i &lt; size(); i++) {            System.out.print(get(i) + \" \");        }        System.out.println();    }}\nDeque\npackage deque;/** * @author Moiads */public interface Deque&lt;T&gt; {    default boolean isEmpty() {        return size() == 0;    }    int size();    void addFirst(T element);    void addLast(T element);    T removeFirst();    T removeLast();    T get(int index);    void printDeque();}\ngh2\nGuitarString\n这个比较简单,根据需求直接应用我们刚刚写的数据结构.\npackage gh2;import deque.ArrayDeque;import deque.Deque;/** * @author Moiads *///Note: This file will not compile until you complete the Deque implementationspublic class GuitarString {    /**     * Constants. Do not change. In case you're curious, the keyword final     * means the values cannot be changed at runtime. We'll discuss this and     * other topics in lecture on Friday.     */    // Sampling Rate    private static final int SR = 44100;    // energy decay factor    private static final double DECAY = .996;    /* Buffer for storing sound data. */    private final Deque&lt;Double&gt; buffer;    /* Create a guitar string of the given frequency.  */    public GuitarString(double frequency) {        int capacity = (int) Math.round(SR / frequency);        buffer = new ArrayDeque&lt;&gt;();        for (int i = 0; i &lt; capacity; i++) {            buffer.addFirst(0.0);        }    }    /* Pluck the guitar string by replacing the buffer with white noise. */    public void pluck() {        for (int i = 0; i &lt; buffer.size(); i++) {            buffer.removeFirst();            double r = Math.random() - 0.5;            buffer.addLast(r);        }    }    /* Advance the simulation one time step by performing one iteration of     * the Karplus-Strong algorithm.     */    public void tic() {        double result = buffer.removeFirst();        result = 0.5 * (result + buffer.get(0)) * DECAY;        buffer.addLast(result);    }    /* Return the double at the front of the buffer. */    public double sample() {        return buffer.get(0);    }}\n","categories":["CS61B"],"tags":["Java"]},{"title":"CS61B-21SP-Project2","url":"/posts/91e85d6d.html","content":"\n个人完成情况: 拿了满分, EC没做.\n花费时间: 一周多, 40个小时左右,debug非常花时间.\n项目地址: GitHub - moiseak/CS61B-SP21\n摸鱼更新中…\n\nClasses and Data Structures\n我的类结构其实很简单,就只有初始的几个类:Main, Reposity, Commit.\n数据结构大多使用HashMap.\nMain\nMain其实没什么好说的,我只把Main当作一个入口,没有定义其他的Fields or Functions.需要注意的无非就是几个特殊情况的处理.\npublic static void main(String[] args) {      // TODO: what if args is empty?      if (args.length == 0) {          System.out.println(\"Please enter a command.\");          System.exit(0);      }      String firstArg = args[0];      switch(firstArg) {          case \"init\":              try {                  Repository.init();              } catch (IOException e) {                  throw new RuntimeException(e);              }              break;          case \"add\":              String secondArg = args[1];              try {                  Repository.add(secondArg);              } catch (IOException e) {                  throw new RuntimeException(e);              }              break;          case \"commit\":              //args : commit message              if (args.length == 1) {                  System.out.println(\"Please enter a commit message.\");                  System.exit(0);              }              String secondArg1 = args[1];              if (\"\".equals(secondArg1)) {                  System.out.println(\"Please enter a commit message.\");                  System.exit(0);              }              try {                  Repository.commit(secondArg1);              } catch (IOException e) {                  throw new RuntimeException(e);              }              break;          case \"log\":              Repository.log();              break;          case \"checkout\":              // maybe\"--\", commitId, or branch              String secondArg2 = args[1];              int len = args.length;              if (len == 3) {                  if (\"--\".equals(secondArg2)) {                      //first arg checkout, second is \"--\", third is file name                      //checkout -- []                    // filename                    String thirdArg = args[2];                      //arg is filename                      try {                          Repository.checkout(thirdArg);                      } catch (IOException e) {                          throw new RuntimeException(e);                      }                  }              } else if (len == 4){                  String fourthArg = args[2];                  if (Objects.equals(fourthArg, \"--\")) {                      //args: first is checkout, second is commitId, third is --\", fourth is filename                      //checkout [] -- []                      //filename                    String fifthArg = args[3];                      //args are commitId and file name                      try {                          Repository.checkoutCommit(secondArg2, fifthArg);                      } catch (IOException e) {                          throw new RuntimeException(e);                      }                  } else {                      System.out.println(\"Incorrect operands.\");                      System.exit(0);                  }              } else {                  try {                      Repository.checkBranch(secondArg2);                  } catch (IOException e) {                      throw new RuntimeException(e);                  }              }              break;          case \"rm\":              String secondArg3 = args[1];              try {                  Repository.rm(secondArg3);              } catch (IOException e) {                  throw new RuntimeException(e);              }              break;          case \"global-log\":              Repository.logGlobal();              break;          case \"find\":              String secondArg4 = args[1];              Repository.find(secondArg4);              break;          case \"status\":              if (!Repository.GITLET_DIR.exists()) {                  System.out.println(\"Not in an initialized Gitlet directory.\");                  System.exit(0);              }              Repository.status();              break;          case \"branch\":              String secondArg5 = args[1];              Repository.branch(secondArg5);              break;          case \"rm-branch\":              String secondArg6 = args[1];              Repository.rmBranch(secondArg6);              break;          case \"reset\":              String secondArg7 = args[1];              try {                  Repository.reset(secondArg7);              } catch (IOException e) {                  throw new RuntimeException(e);              }              break;          case \"merge\":              String secondArg8 = args[1];              try {                  Repository.merge(secondArg8);              } catch (IOException e) {                  throw new RuntimeException(e);              }              break;          default:              System.out.println(\"No command with that name exists.\");              System.exit(0);      }}\nCommit\nFields\n利用一个哈希表来存储文件与文件哈希值的映射\nprivate final String message;  private final String commitDate;  private final String hashCodeCommit;  private final String parent;  private String parent2 = null;//mergeprivate final String mergeMessage;  //file and file hash value  private HashMap&lt;String, String&gt; fileHashcode = new HashMap&lt;&gt;();\nFunctions\n使用了三个构造函数,一个是构造初始提交,一个是构造普通提交,一个是构造合并提交.\n还有一个判断这个Commit是否追踪了某个文件的函数.\ncommit操作就不必多说了.\n//about mergepublic String getMergeMessage() {      return mergeMessage;  }    public String getParent2() {      return parent2;  }  public Commit() {      this.message  = \"initial commit\";      this.mergeMessage = \"\";      Date d = new Date(0);      SimpleDateFormat sdf = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy Z\", Locale.ENGLISH);      sdf.setTimeZone(TimeZone.getTimeZone(\"GMT-8:00\"));      this.commitDate = sdf.format(d);      this.parent = \"\";      this.hashCodeCommit = Utils.sha1(this.message, this.commitDate);  }    public Commit(String message, String parent) {      this.message = message;      this.parent = parent;      this.mergeMessage = \"\";      Date d = new Date();      SimpleDateFormat sdf = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy Z\", Locale.ENGLISH);      sdf.setTimeZone(TimeZone.getTimeZone(\"GMT-8:00\"));      this.commitDate = sdf.format(d);      hashCodeCommit = Utils.sha1(this.message, this.commitDate, this.parent);  }    public Commit(String message, String parent, String mergeMessage, String parent2) {      this.message = message;      this.parent = parent;      this.mergeMessage = mergeMessage;      this.parent2 = parent2;      Date d = new Date();      SimpleDateFormat sdf = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss yyyy Z\", Locale.ENGLISH);      sdf.setTimeZone(TimeZone.getTimeZone(\"GMT-8:00\"));      this.commitDate = sdf.format(d);      hashCodeCommit = Utils.sha1(this.message, this.commitDate, this.parent, this.mergeMessage);  }    public boolean isTracked(String fileName, String fileHash) {  \treturn fileHashcode.containsKey(fileName) &amp;&amp; fileHashcode.get(fileName).equals(fileHash);  }    public HashMap&lt;String, String&gt; getFileHashcode() {      return this.fileHashcode;  }    public void setFileHashcode(HashMap&lt;String, String&gt; fileHashcode) {      this.fileHashcode = fileHashcode;  }    public void addFileHashcode(String filename, String hashcode) {      this.fileHashcode.put(filename, hashcode);  }    public String getHashcodeCommit() {      return this.hashCodeCommit;  }    public String getMessage() {      return this.message;  }    public String getDate() {      return this.commitDate;  }    public String getParent() {      if (Objects.equals(this.parent, \"\")) {          return null;      }      return this.parent;  }    public void commit() throws IOException {      File commitFile = Utils.join(Repository.COMMIT, this.getHashcodeCommit());      commitFile.createNewFile();      Utils.writeObject(commitFile, this);  }\nRepository\nFields\n个人感觉我的注释写的够清楚了(赞赏).\n文件系统:\n/* The current working directory. */  public static final File CWD = new File(System.getProperty(\"user.dir\"));  /* The .gitlet directory. */  public static final File GITLET_DIR = join(CWD, \".gitlet\");  /* The staging */  public static final File STAGING_AREA = join(GITLET_DIR, \"staging\");  public static final File RM_AREA = join(GITLET_DIR, \"rm\");  //Each constant that needs to be saved  //all commits  public static final File COMMIT = Utils.join(Repository.GITLET_DIR, \"commit\");  //HEAD commit  public static final File HEAD_FILE = join(GITLET_DIR, \"HEAD\");  //hashmap about commitId to commit  public static final File COMMITS_FILE = join(GITLET_DIR, \"commits\");  //hashmap about filename to file a byte array  public static final File BLOBS_FILE = join(GITLET_DIR, \"blobs\");  //hashmap about branch name to branch  public static final File BRANCHES_FILE = join(GITLET_DIR, \"branches\");  //current branch  public static final File BRANCH_FILE = join(GITLET_DIR, \"branch\");\n变量:\n//Commit hash value to commit mapping  private static HashMap&lt;String, Commit&gt; commits = new HashMap&lt;&gt;();  //current commit  private static Commit HEAD;  //current branch  private static class Branch implements Serializable {      private final String name;      private Commit commit;      Branch(String name, Commit commit) {          this.name = name;          this.commit = commit;      }  }  private static Branch currentBranch;  //branches  private static HashMap&lt;String, Branch&gt; branches = new HashMap&lt;&gt;();  //string is file hash value, byte[] is file content  private static HashMap&lt;String, byte[]&gt; blobs = new HashMap&lt;&gt;();\nFunctions\n对于文件的处理, createFile readAll和saveAll用来一键创建,读取和保存.\ninit:\n这个没什么难度,创建一些文件,进行一个初始提交就可以了.\npublic static void init() throws IOException {      if (!GITLET_DIR.exists()) {          GITLET_DIR.mkdir();      } else {          System.out.println(\"A Gitlet version-control system \"                  + \"already exists in the current directory.\");          return;      }      createFile();      //first commit      Commit firstCommit = new Commit();      HEAD = firstCommit;      firstCommit.commit();      commits.put(firstCommit.getHashcodeCommit(), firstCommit);      //default branch name is master      Branch master = new Branch(\"master\", firstCommit);      currentBranch = master;      branches.put(\"master\", master);      saveAll();  }\nadd:\n这个值得一提的是需要同时处理两种暂存区:添加和删除,也就是如果我们要添加的文件就在删除区的话,我们要进行一个\"unremove\"操作,把他从删除区移除.其他的都很好理解,在blobs表中创建一个副本,然后保存blobs文件.把本地文件上传到添加暂存区.\n@SuppressWarnings(\"unchecked\")  public static void add(String file) throws IOException {      blobs =  readObject(BLOBS_FILE, HashMap.class);      HEAD = readObject(HEAD_FILE, Commit.class);      //if file in rm stage, then \"unremove\"      List&lt;String&gt; rm = plainFilenamesIn(RM_AREA);      if (rm != null) {          for (String f : rm) {              if (f.equals(file)) {                  File beDeleted = join(RM_AREA, f);                  beDeleted.delete();                  return;              }          }      }      //find a local file      File add = join(CWD, file);      if (!add.exists()) {          System.out.println(\"File does not exist.\");          return;      }      String addHash = sha1((Object) readContents(add));      //file equal HEAD's file      if (HEAD.getFileHashcode().containsKey(file)) {          if (HEAD.getFileHashcode().get(file).equals(addHash)) {              return;          }      }      //create the file in stage area      File addStage = join(STAGING_AREA, file);      writeContents(addStage, (Object) readContents(add));      addStage.createNewFile();      if (!blobs.containsKey(addHash)) {          blobs.put(addHash, readContents(add));      }      writeObject(BLOBS_FILE, blobs);  }\ncommit:\n这是一个涉及到很多部分的操作,如果是正常的提交,那就创建正常的Commit,如果是从merge来的提交,就需要创建mergeCommit了.\n判断两个暂存区是否为空,如果不为空就进行add&amp;remove操作,并且清理两个暂存区.\n在添加时还要判断这个更新是否是有效的,如果内容没有改变就不进行添加.\npublic static void commit(String ... message) throws IOException {      readAll();      String parentHash = HEAD.getHashcodeCommit();      Commit commit = new Commit();      if (message.length == 1) {          commit = new Commit(message[0], parentHash);      }      if (message.length == 3) {          commit = new Commit(message[0], parentHash, message[1], message[2]);      }      //Defaults to the same file as the parent commit      commit.setFileHashcode(HEAD.getFileHashcode());      //get all filenames in stage      List&lt;String&gt; hashList = plainFilenamesIn(STAGING_AREA);      List&lt;String&gt; hashListRm = plainFilenamesIn(RM_AREA);      if (hashList != null              &amp;&amp; hashListRm != null              &amp;&amp; hashList.isEmpty()              &amp;&amp; hashListRm.isEmpty()) {          System.out.println(\"No changes added to the commit.\");      }      //clear add stage      if (hashList != null) {          for (String s : hashList) {              //whether you find              boolean flag = false;              File file = join(STAGING_AREA, s);              String fileHash = sha1((Object) readContents(file));              //Determine whether the file hash corresponding              if (commit.getFileHashcode().isEmpty()) {                  flag = true;                  commit.addFileHashcode(s, fileHash);                  file.delete();              } else {                  //key is filename                  for (String key : commit.getFileHashcode().keySet()) {                      //find equal filename                      if (s.equals(key)) {                          commit.addFileHashcode(key, fileHash);                          flag = true;                          file.delete();                      }                  }              }              //not find and not null              if (!flag) {                  commit.addFileHashcode(s, fileHash);                  file.delete();              }          }      }      //clear rm stage      if (hashListRm != null) {          for (String r : hashListRm) {              commit.getFileHashcode().remove(r);              File rmF = join(RM_AREA, r);              rmF.delete();          }      }      //save      commit.commit();      HEAD = commit;      currentBranch.commit = commit;      //update      branches.put(currentBranch.name, currentBranch);      commits.put(commit.getHashcodeCommit(), commit);      saveAll();}\nlog &amp; global-log:\n一个是只打印当前分支提交的信息,一个是打印所有提交的信息.\n创建一个辅助打印函数,然后从HEAD开始向上查询或者直接遍历commits即可.\n@SuppressWarnings(\"unchecked\")  public static void log() {      HEAD = readObject(HEAD_FILE, Commit.class);      commits = readObject(COMMITS_FILE, HashMap.class);      while (HEAD != null) {          printCommit();          HEAD = (Commit) commits.get(HEAD.getParent());      }  }\n//print all commit  @SuppressWarnings(\"unchecked\")  public static void logGlobal() {      List&lt;String&gt; commitList = plainFilenamesIn(COMMIT);      commits = readObject(COMMITS_FILE, HashMap.class);      if (commitList != null) {          for (String s : commitList) {              Commit commit = commits.get(s);              printCommit(commit);          }      }  }\ncheckout:\n三种情况,写三个函数.后面的命令会频繁用到.\n首先来看第一种情况,这种情况比较简单,我们只需要判断HEAD中是否含有指定文件,若有就把它checkout到CWD.\n然后来看第二种情况,第一步是判断传过来的是不是shortId,不要误报错.然后我们就需要从指定提交中获得该文件,但是如果存在覆盖未追踪的文件的情况,必须报错返回.\n最后一种情况是得到指定分支中的所有文件,那么我们就可以先遍历指定Branch,然后就可以使用我们在第二种情况创建的函数来检出所有文件.\n//checkout HEAD file to CWD  @SuppressWarnings(\"unchecked\")  public static void checkout(String file) throws IOException {      HEAD = readObject(HEAD_FILE, Commit.class);      blobs = readObject(BLOBS_FILE, HashMap.class);      File checkoutFile = join(CWD, file);      //Determine whether there are files to be checked out      if (!HEAD.getFileHashcode().containsKey(file)) {          System.out.println(\"File does not exist in that commit.\");          return;      }      //Get the file and write it      String checkHash = HEAD.getFileHashcode().get(file);      byte[] checkFile = blobs.get(checkHash);      writeContents(checkoutFile, (Object) checkFile);      checkoutFile.createNewFile();  }    //checkout commit corresponds commitId 's file to CWD  public static void checkoutCommit(String commitId, String file) throws IOException {      readAll();      HashMap&lt;String, String&gt; shortId = new HashMap&lt;&gt;();      for (String s : commits.keySet()) {          String shortI = getShortId(s);          shortId.put(shortI, s);      }      if (shortId.containsKey(commitId)) {          commitId = shortId.get(commitId);      }      //Whether to include this commit      if (!commits.containsKey(commitId) &amp;&amp; !shortId.containsKey(commitId)) {          System.out.println(\"No commit with that id exists.\");          return;      }      Commit checkCommit = commits.get(commitId);      //whether this commit have the file      if (!checkCommit.getFileHashcode().containsKey(file)) {          System.out.println(\"File does not exist in that commit.\");          return;      }      String checkfileHash = checkCommit.getFileHashcode().get(file);      File cwdFile = join(CWD, file);      isUntracked(file, checkfileHash);      //get file content and write in CWD      byte[] checkByte = blobs.get(checkfileHash);      cwdFile.createNewFile();      writeContents(cwdFile, (Object) checkByte);  }    private static void isUntracked(String file, String checkfileHash) {      File cwdFile = join(CWD, file);      String cwdHash = null;      if (cwdFile.exists()) {          cwdHash = sha1((Object) readContents(cwdFile));      }      if (!checkfileHash.equals(cwdHash)              &amp;&amp; !isTracked(file, cwdHash)              &amp;&amp; cwdHash != null) {          System.out.println(\"There is an untracked file in the way;\"                  + \" delete it, or add and commit it first.\");          System.exit(0);      }  }    @SuppressWarnings(\"unchecked\")  public static void checkBranch(String branch) throws IOException {      HEAD = readObject(HEAD_FILE, Commit.class);      currentBranch = readObject(BRANCH_FILE, Branch.class);      branches = readObject(BRANCHES_FILE, HashMap.class);      Branch giveBranch = branches.get(branch);      if (!branches.containsKey(branch)) {          System.out.println(\"No such branch exists.\");          return;      }      if (giveBranch.name.equals(currentBranch.name)) {          System.out.println(\"No need to checkout the current branch.\");          return;      }      List&lt;String&gt; cwd = plainFilenamesIn(CWD);      if (cwd != null) {          for (String s : cwd) {              File cwdF = join(CWD, s);              String cwdHash = sha1((Object) readContents(cwdF));              if (HEAD.getFileHashcode().containsValue(cwdHash)                      &amp;&amp; !giveBranch.commit.getFileHashcode().containsKey(s)) {                  cwdF.delete();              }          }      }      for (String key : giveBranch.commit.getFileHashcode().keySet()) {          checkoutCommit(giveBranch.commit.getHashcodeCommit(), key);      }      currentBranch = branches.get(branch);      HEAD = branches.get(branch).commit;      branches.put(currentBranch.name, currentBranch);      writeObject(HEAD_FILE, HEAD);      writeObject(BRANCH_FILE, currentBranch);      writeObject(BRANCHES_FILE, branches);  }","categories":["CS61B"],"tags":["Java"]},{"title":"Centos7更新gcc到9","url":"/posts/450ba28c.html","content":"Centos7已经与2024年6月30日停止维护，yum源也无法使用了。\n如果运行\nyum -y install centos-release-scl\n会得到\nCould not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock error was14: curl#6 - \"Could not resolve host: mirrorlist.centos.org; 未知的错误\"\n此时可以\nsed -i s/mirror.centos.org/vault.centos.org/g /etc/yum.repos.d/*.reposed -i s/^#.*baseurl=http/baseurl=http/g /etc/yum.repos.d/*.reposed -i s/^mirrorlist=http/#mirrorlist=http/g /etc/yum.repos.d/*.reposed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-*sed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-*\n之后\nyum clean allyum makecache\n然后就可以安装centos-release-scl了\nyum -y install centos-release-scl\n安装完之后我们进入/etc/yum.repos.d/可以发现多了两个repo\ncd /etc/yum.repos.d/\nCentOS-SCLo-scl.repo和CentOS-SCLo-scl-rh.repo\nll总用量 48-rw-r--r--. 1 root root 1669 1月  10 13:21 CentOS-Base.repo-rw-r--r--. 1 root root 1309 1月  10 13:21 CentOS-CR.repo-rw-r--r--. 1 root root  649 1月  10 13:21 CentOS-Debuginfo.repo-rw-r--r--. 1 root root  315 1月  10 13:21 CentOS-fasttrack.repo-rw-r--r--. 1 root root  630 1月  10 13:21 CentOS-Media.repo-rw-r--r--. 1 root root  998 12月 11 2018 CentOS-SCLo-scl.repo-rw-r--r--. 1 root root  971 10月 29 2018 CentOS-SCLo-scl-rh.repo-rw-r--r--. 1 root root 1332 1月  10 13:21 CentOS-Sources.repo-rw-r--r--. 1 root root 8515 1月  10 13:21 CentOS-Vault.repo-rw-r--r--. 1 root root  618 1月  10 13:21 CentOS-x86_64-kernel.repo\n对这两个repo进行部分修改\nvi /etc/yum.repos.d/CentOS-SCLo-scl.repo\n[centos-sclo-sclo]name=CentOS-7 - SCLo sclobaseurl=https://mirrors.aliyun.com/centos/7/sclo/x86_64/sclo/# mirrorlist=http://mirrorlist.centos.org?arch=$basearch&amp;release=7&amp;repo=sclo-sclogpgcheck=0enabled=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-SCLo\nvi /etc/yum.repos.d/CentOS-SCLo-scl-rh.repo\n[centos-sclo-rh]name=CentOS-7 - SCLo rhbaseurl=https://mirrors.aliyun.com/centos/7/sclo/x86_64/rh/# mirrorlist=http://mirrorlist.centos.org?arch=$basearch&amp;release=7&amp;repo=sclo-rhgpgcheck=0enabled=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-SCLo\n刷新缓存\nyum repolistyum clean allyum makecache\n之后进入/opt/安装gcc9\ncd /opt/yum -y install devtoolset-9-gcc*\n该文件会下载在/opt/rh/\ncd rh/cd devtoolset-9/source ./enable\n检查版本发现更新成功\ngcc --versiongcc (GCC) 9.3.1 20200408 (Red Hat 9.3.1-2)\n","categories":["学习笔记"],"tags":["Linux"]},{"title":"Hashing","url":"/posts/66e3f11.html","content":"目的\n为了得到更快的添加数据和判断该数据结构是否包含某数据的速度(即add&amp;contain的速度).\n尝试\n(一)\n我们可以设想一个boolean数组,我们每添加一个非负整数,就把它当成数组的索引,然后把对应位置的数据改为true.这样我们就得到了一个add&amp;contain都为O(1)的数据结构.\n那如果我们要处理字符串呢?比如\"cat\" “dog”,一个自然的想法是我们可以把首字母转换为数字来当作索引,比如c对应3,d对应4.我们就又可以得到一个add&amp;contain字符串都为O(1)的数据结构.但这个结构存在非常明显的问题:\n“?” 之类的符号怎么存储?\n并且\"cat\" “come” “candy\"都是c开头的,于是就发生了\"碰撞”.\n(二)\n继续想办法解决,我们知道存在ASCII表,于是我们就能把所有的数字,字母,符号都转化为数字,为了避免碰撞,我们还可以对数据进行固定的处理,比如base27,即个位 * 27^0, 十位 * 27^1,以此类推可以得到一个重复率较低的数字.\n比如\"cat\"得到9999就把索引为9999的数据改为true,\"12!sda\"得到88888就把对应的数据改为true.\n那汉字呢?好办,换个字符集不就可以了,比如unicode.\n但在又存在一个问题,为了存储索引为9999的数据,我们不得不创建一个大小为9998的数组,而这个数组中存在大量的空缺,这就导致的非常多的内存浪费.\n并且由于我们得到的索引数太大了,甚至会频繁导致溢出.\n有没有办法让我们在大小为10的数组里也能根据索引存储这些数据呢?\n(三)\n用 “%” !\n我们把直接得到的哈希值进行模运算,数组size为10就 %10,size多少就%上多少.这样就能正常的存储在size比较小的数组中了.\n正常存储后碰撞的问题又进入到我们的视野,99,899,8889都会得到9这个索引,那怎么办?,如何存储这些碰撞的数据?\n设计一个优秀的哈希函数就非常重要了,既需要保证相同的数据一定能得到相同的哈希值,又需要尽量降低不同数据得到相同哈希值的概率,不过不用担心,有人帮我们设计好了.java内置有一个.hashcode()函数,我们可以直接通过这个得到哈希值.\n(四)\n这时来看我们最初的布尔数组就有些过时了,大伙都在进化怎么就你拉跨呢?\n那我们就干脆用数组存储LinkedList,得到相同索引的数据全放在这个链表中,但与此同时我们的contain函数也退化了,因为我们不仅要通过数据来得到哈希值对应的索引,我们还需要遍历对应数组里的元素来查找到底有没有这个数据.即为O(Q),Q就是最长链表的长度.\n为了改善这个问题,我们需要尽量降低Q的大小,所以就用到了数组的扩容,毕竟数组扩大了,数据也就更分散了,链表的长度也会随之降低.那究竟什么时候扩容呢?\n这时我们要用到一个叫做负载因子的东西来判断数组扩容的时机.\n当目前的负载因子大小达到我们规定的大小时就会进行数组扩容,java的默认值为0.75.\n也就是说,如果我们的元素分布的足够均匀,比如,每个链表只有一个元素,我们依然可以得到O(1)\n","categories":["学习笔记"],"tags":["算法","数据结构"]},{"title":"K 个一组反转链表","url":"/posts/1555c571.html","content":"25. K 个一组翻转链表 - 力扣（LeetCode）\n难度：Hard。\n给你链表的头节点&nbsp;head&nbsp;，每&nbsp;k&nbsp;个节点一组进行翻转，请你返回修改后的链表。\nk&nbsp;是一个正整数，它的值小于或等于链表的长度。如果节点总数不是&nbsp;k&nbsp;的整数倍，那么请将最后剩余的节点保持原有顺序。\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[2,1,4,3,5]\n这个问题具有递归性质，如果我们反转了前两个节点，那么剩下的节点是一个头节点变为原链表第三个节点，长度变为n-2的一条新链表，并且我们需要对这条的处理与原链表是一样的。对新链表的前两个节点进行反转，剩下的节点又是一条新链表，如此…\n那么我们首先要解决的一个问题是：如何反转一条链表的前两（N）个节点？\n同样用递归来解决，我们定义一个函数reverseN的作用是反转前N个节点，那么我们只需要将头节点接在以第二个节点为头节点，反转前N-1个节点后的链表最后面。\n即：\nListNode afterNode = Node; //第N+1个节点，用来接在前N个节点反转后的新链表后面ListNode newNode = reverseN(head.next, n - 1);head.next.next = head; //将head接在最后head.next = afterNode;  //接上第N+1及后面的节点\n完整解法如下：\nListNode after = null;// 反转以 head 为起点的 n 个节点，返回新的头结点ListNode reverseN(ListNode head, int n) {    if (n == 1) {        // 记录第 n + 1 个节点        after = head.next;        return head;    }    // 以 head.next 为起点，需要反转前 n - 1 个节点    ListNode last = reverseN(head.next, n - 1);    head.next.next = head;    // 让反转之后的 head 节点和后面的节点连起来    head.next = after;    return last;}\n那么接下来就很简单了：\n1、先反转以&nbsp;head&nbsp;开头的&nbsp;k&nbsp;个元素。\n2、将第&nbsp;k + 1&nbsp;个元素作为&nbsp;head&nbsp;递归调用&nbsp;reverseKGroup&nbsp;函数。\n3、将上述两个过程的结果连接起来。\nclass Solution {    public ListNode reverseKGroup(ListNode head, int k) {\t\tif(head == null) {\t\t\treturn null;\t\t}\t\t//[a, b)为需要反转的区间\t\tListNode a, b;\t\tfor (int i = 0; i &lt; k; i++) {\t\t\t//剩余节点数量不够K个直接返回\t\t\tif (b == null)  return head;\t\t\tb = b.next;\t\t}\t\tListNode newHead = reverseN(a, k);\t\t//此时a为反转后的最后一个节点，将其与反转后的下一组连接起来\t\ta.next = reverseKGroup(b, k);\t\treturn newHead;    }\t\tListNode after = null;\t\t// 反转以 head 为起点的 n 个节点，返回新的头结点\tListNode reverseN(ListNode head, int n) {\t\tif (n == 1) {\t\t// 记录第 n + 1 个节点\t\t\tafter = head.next;\t\t\treturn head;\t\t}\t\t// 以 head.next 为起点，需要反转前 n - 1 个节点\t\tListNode last = reverseN(head.next, n - 1);\t\t\t\thead.next.next = head;\t\t// 让反转之后的 head 节点和后面的节点连起来\t\thead.next = after;\t\treturn last;\t}}\n不要跳进递归，而是去利用递归的定义。\n","categories":["题解"],"tags":["算法"]},{"title":"MST","url":"/posts/7a935cfb.html","content":"生成树\n\n存在图中的所有顶点\n每个节点都已连接\n无环\n\n最小生成树\n在权重图中得到权重最小的生成树就是最小生成树(MST).\nCut Property\n将图中的节点分到两个集合,这两个集合最小权重的交叉边一定在MST中.\n证明:反证法,如果最小权重边e不在MST中,则将e加入MST构成环,再去掉另一条边就可以得到一个包含e的并且更小的生成树.\nPrim 算法\n\n从任意一个节点开始,把它放入到MST中.\n找到MST中顶点所有相邻的边中最短的边,并且把这个边所连接的另一个顶点也加入到MST中\n重复上步骤直到我们拥有了总节点数-1条边.\n\n可以根据剪切性质轻松证明.\n优化\n第二步每次都view所有相邻的边是不是会重复view很多条边,如何优化?回忆以下Dijkstra算法,我们下面要用到一个比较相似的机制:减少活动的节点数,MST中只允许一个活动节点,并且借助优先队列来更新\"不活动的节点\"和节点对应的权重.\n很遗憾我无法用三言两语讲清楚,请观看这个视频:vid7 prims efficient - YouTube\n相信你看完之后就能理解我上面的不那么清楚的表述了.\nKruskal 算法\nprim是通过遍历节点来确定MST,那么kruskal则是通过遍历边,也更直观一些.\n\n排序所有边\n从小依次添加,前提是添加该边不会导致成环\n直到我们有了总节点数-1条边\n\n实现:利用优先队列存储每条边,再用连接图(WQU)判断是否成环.\n二者对比\nvid10 kruskals vs prims - YouTube\n","categories":["学习笔记"],"tags":["算法"]},{"title":"Spring（二）","url":"/posts/2d3a27c0.html","content":"AOP\n概念\nAOP的就是在运行时增强我们指定的方法，动态的将代码切入到指定方法的指定位置。也就是说我们可以利用AOP在多个方法的前后增加一些重复性的操作。\n比如我们要在每个方法前面打印日志，就可以利用AOP来实现。在不改动原代码的情况下，对我们的代码进行了增强。\n\n在某个地方把我们的逻辑切断，在切断处进行一个额外的操作，然后再把逻辑续上。\n配置\nxml和接口的使用就不说了，毕竟我们主要还是使用注解开发。\n首先我们需要在主类添加@EnableAspectJAutoProxy注解，开启AOP注解支持：\n@EnableAspectJAutoProxy @ComponentScan(\"org.example.entity\") @Configuration public class MainConfiguration { }\n注册一个Bean：\n@Component public class Student { \tpublic void study(){ \t\tSystem.out.println(\"我是学习方法！\"); \t} }\n接着我们需要在定义AOP增强操作的类上添加@Aspect注解和@Component将其注册为Bean即可，就像我们之前在配置文件中也要将其注册为Bean那样：\n@Aspect @Component public class StudentAOP { }\n比如我们要在study之前执行我们的增强代码：\n@Before(\"execution(* org.example.entity.Student.study())\") //execution写法跟之前一样 public void before(){ System.out.println(\"我是之前执行的内容！\"); }\n除了Before，还有其他的位置可以使用。\n","categories":["学习笔记"],"tags":["Java","Spring"]},{"title":"Spring（一）","url":"/posts/1d2ccb18.html","content":"IoC\nIoC的意思是“控制反转”，就是把我们创建对象实例的权力交给Spring框架，我们不需要再自己手动去new一个对象。它会根据我们的配置文件去帮助我们实现类，目的是解耦各个模块，就是降低各个模块之间互相依赖的程度。\n我们交给IoC控制的对象就叫做Bean。\n配置\n基础配置\n引入Spring依赖：\n&lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-context&lt;/artifactId&gt;   &lt;version&gt;6.0.10&lt;/version&gt; &lt;/dependency&gt;\nresource中创建一个Spring配置文件：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\t   xsi:schemaLocation=\"http://www.springframework.org/schema/beans \t   https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt;  \n我们通过一个应用程序上下文来索要我们的Bean，在Main中：\npublic static void main(String[] args) { \tApplicationContext context = new ClassPathXmlApplicationContext(\"test.xml\"); }\n假如我们创建了一个名为Student的类，我们就可以在Spring配置文件中将它交给IoC容器管理（这个配置文件就是我们上面写的那个\"test.xml\"）：\n&lt;bean class=\"com.test.bean.Student\"/&gt;\n这就成功把Student这个类交给IoC容器了。如果我们想要使用这个类，只需要向上下文索要就行：\nStudent student = context.getBean(Student.class);\nBean的配置\nBean可以配置名字或者别名，并且可以根据名字/别名来获取，别名需要另起一行：\n&lt;bean name=\"a\" class=\"com.test.bean.Student\"/&gt;&lt;alias name=\"a\" alias=\"test\"/&gt;\nBean默认为单例模式，也就是IoC容器只会给我们创建一个对象，不管索要多少次都会是这一个对象，如果要改为每次索要就创建一个新的对象，可以加上一个scope参数，配置为：\n&lt;bean name=\"a\" class=\"com.test.bean.Student\" scope=\"prototype\"/&gt;\n另外，如果我们希望Bean对象在使用时才创建，可以改为懒加载（默认为Spring项目启动时就创建）\n&lt;bean class=\"com.test.bean.Student\" lazy-init=\"true\"/&gt;\n如果想要控制加载顺序，可以加上一个参数：\n&lt;bean name=\"teacher\" class=\"com.test.bean.Teacher\"/&gt; &lt;bean name=\"student\" class=\"com.test.bean.Student\" depends-on=\"teacher\"/&gt;\n这样Teacher就会在Student前加载。\n依赖注入\n用来指定Bean中变量的值。\n指定student中的teacher变量，引用类型用ref，其他用value：\n&lt;bean name=\"teacher\" class=\"com.test.bean.ProgramTeacher\"/&gt; &lt;bean name=\"student\" class=\"com.test.bean.Student\"&gt; \t&lt;property name=\"teacher\" ref=\"teacher\"/&gt; \t&lt;property name=\"id\" value=\"111\"/&gt;&lt;/bean&gt;\n添加property其实是调用set方法，所以记得在student类中加入set方法。\n但是调用的构造方法是默认的无参构造，如果我们有自己定义的构造方法，就需要使用constructor-arg：\n&lt;bean name=\"teacher\" class=\"com.test.bean.ArtTeacher\"/&gt; &lt;bean name=\"student\" class=\"com.test.bean.Student\"&gt; \t&lt;constructor-arg name=\"teacher\" ref=\"teacher\"/&gt; &lt;/bean&gt;\n它还会根据变量的个数自动匹配构造参数，如果想要指定变量类型，可以再加一个type。\n如果是集合类型，会有特殊的支持，请自行根据需要查阅。\n自动装配\n&lt;bean name=\"student\" class=\"com.test.bean.Student\" autowire=\"byType\"/&gt;\n注解开发\n不需要xml文件了，只需要一个配置类（可以通过Import引入其他配置类）：\n@Configuration public class MainConfiguration { \t@Bean(\"student\") \tpublic Student student(){ \t\treturn new Student(); \t}}\nMain中：\nApplicationContext context = new   AnnotationConfigApplicationContext(MainConfiguration.class); //这个构造方法可以接收多个配置类（更准确的说是多个组件）\n还可以配置其他属性：\n@Bean @Lazy(true) //对应lazy-init属性 @Scope(\"prototype\") //对应scope属性 @DependsOn(\"teacher\") //对应depends-on属性 public Student student(){ return new Student(); }\n如果需要引入其他的Bean，直接当参数传入即可：\n@Configuration public class MainConfiguration { \t@Bean \tpublic Teacher teacher() { \t\treturn new Teacher(); \t} \t@Bean \tpublic Student student(Teacher teacher) { \t\treturn new Student(teacher); \t} }\n自动装配：\npublic class Student { \t@Autowired //使用此注解来进行自动装配，由IoC容器自动为其赋值 \tprivate Teacher teacher; }\n如果是我们自己创建的类，可以在类文件中加入注解@Component，就不需要再在配置文件中配置为Bean了：\n@Component(\"test\") //同样可以自己起名字 public class Student { }\n然后配置一下包扫描：\n@Configuration @ComponentScan(\"com.test.bean\") //包扫描，这样Spring就会去扫描对应包下所有的类 public class MainConfiguration { }","categories":["学习笔记"],"tags":["Java","Spring"]},{"title":"周记(一)","url":"/posts/22555b07.html","content":"总结\n经过一周的折腾和思考，也终于在今天把要学的东西整理好了，这不是说最近没学习，而是最近学得很乱，什么都学一点，主要还是 61A 和 61B 的学习版本没定下来吧，之前由于我的精神强迫症，想着开学后跟着课程表走的，但是… 很麻烦，资料不全,课程表进度太慢等等，而且 61A 我已经学了一点 了，从头开始学有点难受，毕竟我是一个不喜欢回头的人.\n这学期我没太考虑逃课，因为好像这些课看起来都不太好翘，而且四天早八我大概率是不翘课的，毕竟不上早八也是在寝室睡觉，不可能起床学习的，那还不如早起去教室呢，多少还能学一点。\njava 课没必要翘，上课也能学，而且老师讲我也要多少听一点，毕竟不知道什么时候课堂测验，总之肯定不能像 C++ 那么摆烂，连测验内容是什么都不知道.\n数字逻辑不好翘，会抽人提问有点难搞.\n离散数学更是重量级，雨课堂出题限时两分钟，别说翘课了，走神都可能会错过很多东西.\n有门课叫大数据编程基础，老师讲的一坨，但是毕竟是上机课，每节课还会布置作业下课交，，，虽然大部分人都写不出来罢…\n至于分析数学…\n这门课我没什么上的欲望啊，老师也是毫无激情,但是我觉得这门课可能会挺难的毕竟我的高数线代概率论全是一坨答辩，所以平时分对我这门课还挺重要的…\n这学期绝对不会重复上学期的惨案了\n原理课 说实话我还挺喜欢听的，感觉讲的很有意思，我平时也喜欢了解一点哲学，虽然连爱好者都算不上，连着听三节课我都没怎么困，这个就听吧，毕竟我的生活除了吃喝玩乐写代码也要有点其他的东西\n体育课就不用说了，肯定不能翘\n规划\n所以这学期我要认真考虑一下在课上的学习内容，可能会在课上看看 61a 和 61b 的 lecture, 虽然我更习惯文字阅读，但上课没事干看看就省的看 ppt 和教材了.\n大概呢是这样的：九月学 61A,24su 版的，为什么只给一个月呢，因为我已经做了大概三分之一了，一个月时间应该能勉强做完.\n过完国庆假期就开始正式学 CS61B 和 data100了，两个多月我觉得差不多能学完吧，CS61B 为主，首先保证 61B 的学习进度，学累了可以看看 data100 缓缓，12 月初一定要保证结束 61B, 然后继续 data100 而且要准备期末了，不过这学期我平时多听一点，期末要复习的也就离散数学，数字逻辑这种课了，比上学校少多了，data100实在做不完可以放到寒假或者不做，不过我觉得这门课的难度应该没那么大，估计也就是比 61A 高一个难度的课程.\n然后还有一门课我觉得有必要写的就是 CS186, 一方面是继续磨练 java,sql 能力，一方面深入了解一下数据库，毕竟我大概率也要从事数据库方面的工作，虽然应该不是开发数据库底层这类比较难的工作，但应该也会参与到数据库的开发中，还是很有必要学一下的。至于 186 和 data100 的优先级如何决定，交给三个月后的我吧.\n这些都是后话了，目前就两件事 61A 61B, 按照先后顺序把这两个完成，而且很丢人的是我到现在都没有完整的学完一门课程，全部都半途而废，全部…\n所以这两门课我一定要从头到尾的完成！\n","categories":["周记"]},{"title":"周记(三)","url":"/posts/f397e04e.html","content":"回顾\n国庆七天没有回家,猛猛写了七天,把61a完结了,但是scheme那个项目做了一半不想做了,可能寒假有空会写写.怎么说呢, 写得很难受,很多地方都特别懵, 只是机械的跟着提示写,完全没什么思考,也不知道自己在写什么,也不知道写出来的东西有什么用,会用在哪,能用在哪,于是摆了.\n我学完的感受就是这门课完全是围绕递归来写的,反而几个proj没什么存在感,前两个太简单,后两个太混乱,感觉设计的有点问题,写起来不是很舒服, 在这门课我递归确实是完完全全地学明白了,至于oop啊这种东西这门课也只是简单的入门,了解一下什么是面向对象就结束了,毕竟只是入门课.递归就是最大的收获.\n学完61a后我就直接开61b了,到现在也学了一周了吧,这周强度还是蛮大的,而且学校的事情真挺多的,上学期都没怎么做过作业,这学期开始认真做了, 发现是真的多啊,如果认真听课学自己做作业确实是没什么时间去自学的. 我的对策就是上课尽量自己学,能带电脑的课比如Java,编程基础,数据库实验这种课都把电脑带过去,效率真比寝室高多了.作业只能求助万能的GPT之神了… 至于其他的课程会选择听lecture/读reading或者学其他的东西,不能带电脑就学点离散.\n这个节奏还是比较舒服的,学自己想学的东西就是会很开心.带电脑上课写代码效率是真的高啊,要是能多几节这种课就好了.不想去实验室,太不自由了, 想干啥还得注意别人,在寝室是太吵了,上课的时候完美符合我的要求,既有学习氛围又没人在意我,安安心心敲代码.\n另外就是其实感觉自己英语水平进步很大了,看Spec比之前轻松多了.\n规划\n其实我的学习速度比我估计要快一点,快的话甚至这个月就能大概结束61b. 能带电脑的课猛猛写代码,不能带电脑的课猛猛看Lecture或者reading.话说我现在更喜欢读reading,其实速度很快,学的也很透彻.\n十月最重要的任务当然就是61b了,然后就是离散数学.cs70的离散数学的notes,我看着很舒服,他那个排版真的不错.这个月尽量把图那部分看完.至于后面的我其实没打算全学完.离散数学我真的不太着急,毕竟我用的那点算法其实不需要多么深厚的数学功底,主要还是靠刷算法题.\n至于之前规划的CS186和data100感觉是没什么机会写了,倒也不是不想学,只是觉得没有必要因为数据库或者数据处理去专门学一门课.\n后面的话会考虑写个java项目,学完csapp/61c.java项目可能会跟着随便写一个吧,一堆java框架都没学,还有什么redis也是毫无了解,也该考虑上手了.其实csapp和61c我没太考虑好学那个,不过csapp因为我学过一部分,上手应该会轻松很多,所以目前是考虑csapp.\n11月我不知道能不能做完. 12月估计是继续完成11月的内容,毕竟我的速度大概率没有我规划的这么快,一个月做一个项目加系统基础感觉会有困难,毕竟csapp的难度我也是亲身体验过的…\n寒假应该会去开MIT操作系统那门课.\n总之,加油吧!\n更新:删了很多东西,拒绝焦虑\n","categories":["周记"]},{"title":"周记(二)","url":"/posts/8d64c065.html","content":"写点\n考试那几天我根本没心情自学，一直在疯狂刷概率论的习题和知识点，并且考完概率论就是中秋假期，狠狠摆烂了好几天，想着这么累休息一下吧，所以进度可以说是丝毫没有进展\n考试间接或直接浪费了我将近两周的学习时间，按说现在我应该 python 部分已经结束了，但事实是我刚开面向对象，结束 python 部分大概率还需要一周左右，scheme 和 sql 部分加上复习怎么也得两周，最快也就是再国庆后几天完成，而且这还是在我国庆不回家的前提下，并且由于我周日有课，平时的周末也很难回家，国庆是寒假前最后一个假期了，不过回去也没什么事情干… 大概率是又浪费一周，目前是没回去的打算，过两天再说吧.\n现在最难受的还是状态问题，头晕晕的，室友又很吵，完全学不进去，带着显示器去实验室又不现实，真难搞啊，最近老是控制不住自己玩，一看就是很久，也没有放松的感觉，打 lol 也是这样，反而还会很累。还是被室友影响了吧，毕竟别人都在玩游戏，我自己看英文课很格格不入，久而久之也就不想看了。而且总是很没精神.\n而且也没胃口，感觉是因为生活不够规律，这么搞老是整的我很烦躁，什么都不规律，好不爽.\n学 61a 还是决定看视频吧，文字要在安静的环境看，但现在找个安静且隐私的环境是真的难，只能放弃.\n更新,现在反而觉得视频要在安静的环境看,所以读比较多\n今天一定要开始行动了，越拖越不想动，上学期我就是这么废的，一定一定要善于总结过去的教训.\n好了，就这样吧.\n更新一下！\n写一下关于上的这几门课的感受吧.\nJava 老师人很好，上课也会给时间自己写他下来帮我们找错误，我挺喜欢上他的课的，不过我没怎么听过，毕竟这几节课他讲的都是基础，我不太需要认真听.\n视听说和读写译都很不错，不会打扰我自学和娱乐，早八上英语课也就背背单词刷刷手机，真没什么动力看 lecture, 太累了，我现在睡得真不算早，每晚上也就睡七个小时左右，早八真的很没精神.\n逻辑设计没什么好说的，翘不了，讲的也不咋地，不喜欢上，配套的实验课还没上.\n数据科学编程基础这门课真闹麻了… 老师脑子有问题，不是发癫嘟囔 “意大利面条拌混凝土” 这种，就是念 ppt 或者 word, 真无敌了，一点都不想去上课.\n数据库系统导论也没啥，正常上课吧，看 61a 的 lecture, 不过实验课每次都有作业，还是要花时间去认真做的.\n离散数学还是老样子，听课，做题，不过感觉他的进度有点慢我还喜欢跑神，我在想要不提前预习，那样可能会好一点.\n政治课都没什么上的欲望，看 61a, 怎么说呢，可能确实有意思，但是我现在 61a 的进度有点紧张，还是不听了，其实也没啥有趣的，主要还是我自己脑子里想象.\n这么看其实我的看 lecture 时间还是挺丰富的，然后就是我其实可以多看几个视频再去做作业也可以，有些看完就可以做，有些我感觉还是再往后面看看再做比较好\n最近白天基本都会喝咖啡，其实真挺有用的，特别是下午会精神不少，虽然最佳的粉水比我还没搞明白，不过现在不会泡出来那种苦的不能喝的了.\n其实应付老师的作业说麻烦也麻烦，说简单也简单，就看能不能把刷视频的时间抽出来一点罢了\n就写到这吧.\n","categories":["周记"]},{"title":"周记（九）","url":"/posts/c4fd8640.html","content":"距离上次写文章已经是将近两个月前了，这中间也想写点东西，比如串流，博客自动部署这些东西，但又觉得意义不大就没写。\n学习\n已经开学两周了，作息还是乱的不行。一到寝室就会怀念在家里独处的时间。\n这两周也没学什么新东西，还是看看算法，八股，大部分时间都因为作息混乱迷迷糊糊，漫画倒是看了不少。这学期课程很满，看着这课表上的计组算法分析数据结构真的头疼，每门课的压力都很大，还有其他几门课要写的作业也挺多。刚开学也比较忙，一直也抽不出时间去写项目，这几天做ppt都要做晕掉了。\n下周在完成课内的情况下，想先熟悉一下项目，然后计组补一下基础知识，再把某网站的算法笔记第零章过一遍。\n其他\n漫画\n这两周漫画看了不少，完结的有炎拳，再见绘梨，终将成为你；还在更的有金牌得主，花如修罗，恋人手中四叶草。都是很有趣的漫画，炎拳我觉得是藤本树的巅峰了，真的是很棒的故事；\n金牌得主我是真的很喜欢，不管是花滑动作还是人物之间的羁绊都很好看，属于是我认为不能错过的作品；花如修罗般绽放，也叫群花绽放，仿若修罗，是京吹原作者的另一部作品，不过不是小说而是漫画，我非常喜欢这部的画风，非常干净，人物画的都很可爱，而且我真的很喜欢这种随便拉两个人都能磕的大乱炖作品…这两部作品都是因为动画化我才接触到的，没想到漫画更好看啊~\n动画\n动画现在看的是这几部：\n\n除了Ave Mujica之外，其他的五部都很推荐看看！\n书籍\n最近在读《堂吉诃德》，是唐民权先生的译本，与之前没读完的杨绛先生译本相比更有意思一点。读的挺慢的，因为前面部分的故事我说不上很喜欢，不过听说后半段很不错，也就先耐着性子读下去吧。\n《穿越计算机的迷雾》有点类似科普读物？但其实也需要大概计算机科班的知识才能看明白，并不算完全的入门书，从原子讲到电&amp;二进制再到磁，后续才开始真正的计算机，涉及到了大量的数电和计组的内容，可惜数电我学的并不好，正好帮我复习一下吧（）\n与我一直学的软件不同，这本书更偏向硬件，读来很开阔视野，虽然以一个科班的视角来看有部分些许罗嗦，不过无伤大雅。\n还有本《置身事内》，读了1/5后放弃了，我对政治的热情仅限于看看知乎的笑话了(～￣▽￣)～。\n好了，先随便写到这里吧，后面可能会写点计组的东西？毕竟数据结构与算法这两门课我好歹学过61B，但计组是真的一头雾水。\n","categories":["周记"]},{"title":"周记(五)","url":"/posts/cebdab86.html","content":"闲聊\n似乎我的博客缺少一些生活气息，我的生活只剩下CS了吗？\n好像的确是这样，没有反馈的日子太煎熬了。这两天又是累的不行，偶尔怀疑自己是不是双相，兴奋一段时间后就是玉玉。\n读了很多前辈们的博文，也想让我的博客有点文艺气息:) 但我确实是好久没读过其他书了，会听点历史书。在考虑抽出来时间读书，可是最近好像魔怔了，似乎所有的时间不用来学习就是罪恶，我的精神似乎是确实要垮了罢。\n或许是想剪头发了，习惯了短发之后稍微长一点就很难受，感觉很头晕,像是被黑暗压着。\nCS\n字节青训营开始了，上一个案例还在写猜数字，下面就开始写socket协议了…这一个月应该会花很多时间在go上。\n其实CS61B相当于结束了，算法部分打算慢慢学，然后学一点就写一点博客，毕竟我二叉树还没刷完，算法不急着赶，慢慢看就可以了。\n还有就是网络是怎么连接的这本书，其实读起来很有意思。\n还买了有关JVM和计组的两本书看看。\n","categories":["周记"]},{"title":"周记（八）","url":"/posts/be30a71f.html","content":"貌似没什么值得记录的，复习完六级就开始复习期末，并且预计接下来两周都是复习期末&amp;考试，其他的学习先放在一边了。上次写的周记显然低估了我的期末压力。\n快放假吧，这样就能安心自学了。\n每天四公里连着跑了两周了，效果确实是有的，精神好了很多，听说是因为大脑会优先处理肉体的疼痛而暂时忽视精神压力，还蛮有道理的。\n想跑出去实习，但是学校根本不会放的吧（笑\n厌倦了合宿生活，只想一个人。\n回忆上次写周记到今天，中间发生了什么竟完全没有记忆，还是要写写日记的。\n","categories":["周记"]},{"title":"周记（十）","url":"/posts/41cfa384.html","content":"CS\n本周主要复习了SSM和Spring Boot，自己写了好多次Controller-Service-Mapper的流程，终于跑熟练了。\n然后把公寓项目跑通了几个接口，但是出现了好多不熟悉的东西，只能见一个学一个。\n算法稍微看了点，还是感觉抽不出来时间写，不知道自己都在忙什么。\n上手写代码的时候发现很多东西虽然大概知道是个什么样子，但实现的时候总是会有一堆问题，那就只能一遍一遍的做直到不再出错。\n其他\n《穿越计算机的迷雾》在继续读；\n又看了一本《精力管理》，书中人的精力被分为体能、情感、思维、意志四方面，感觉我每个方面都很差呢…总之书感觉还是挺不错的，书里给了很多解决案例，还挺有启发的，算是让我对生活更积极了一点吧。\n尝试煎了两次鸡蛋，貌似没有上学期熟练了（\n最近总有种对生活的不真实感，对时间流速的感知越来越迟钝，经常有分不清周二与周四、晚上十点和凌晨两点的感觉，有天甚至写代码到晚上十二点，晚饭都忘记吃了，只得吃几个面包，然后躺在床上迷茫。下周一定一定要写日记，让我留下一点我还活着的证据给下周的我看吧。\n我需要独处\nPlease, I need\n下周计划：\n\nSpring MVC 拦截器\nSpring Boot 自动配置\nMybatis 动态SQL\nMybatisPlus\nKnife4j\n\n","categories":["周记"]},{"title":"周记(四)","url":"/posts/f7f583c.html","content":"java\njavaweb\n大概过了一些,比如mybatis这些,感觉还是得去写,所以只是大概看了看,准备找时间写个项目,等把手头的gitlet做完吧.\n其实脑子里没留下什么痕迹.\njava guide\n认真看了不少,JVM,多线程之类的,感觉很有意思学到了很多.\nCS61B\n依旧是gitlet,勉强完成了一大半吧.我愿称之为入门质检员,真正自己从头写一个项目才知道自己的水平在什么程度.\n感觉我的abstract barrier做的纯是一坨,压根没去有意识分离层次,比如文件层,对象层,应用层这种东西,好多地方都是直接操作文件,感觉有点难维护,不过好像很难重构了,再写写看吧\n今天修了几个小时的Bug,是真的很折磨啊.\n更新: 还是做了一下封装,现在看起来舒服多了\n更新:做完了!\n后续应该要赶一下reading进度了,我现在还在图那个部分.\n我是十月四号左右开的CS61B,目前估计除了proj3其他部分应该能在十一月的第一周完成\n其他\n这几天开始用一个时间日志软件来记录自己的一天.\n越来越认同成长没有捷径这句话了.\n","categories":["周记"]},{"title":"周记（七）","url":"/posts/495b8f5c.html","content":"距离上次写周记居然已经过去20天了，干脆归到一篇里面好了。\n学习\nSSM 和 Spring Boot 基本已经学完了，再学就要去看源码了。这部分更像是对 Java Web 的回顾总结再简化，从编写大量的 Servlet -&gt; Spring 写繁琐的配置文件 -&gt; Spring Boot 一个注解搞定，这个过程真的能体会到如今的企业为什么要依赖 Spring Boot 完成开发，真的方便太多了。\n然后去学了 Redis，开始做一个公寓项目，后面将近两周应该都会花在这个项目上。\n因为学了 Docker，现在基本都懒得配环境，直接在 wsl2 + Docker 里跑，太轻松了。\n算法还是在慢慢刷，感觉速度好慢，下周要加速了，不然钱就白花了…\n12月就要期末了，还得准备考试，这两天已经开始复习了，不过自学和备考之间的有点难以平衡，有时候两个都做不完导致直接摆烂一天。\n上周太懒了，一篇博客都没写，其实学的好多东西还挺需要写笔记的，下周改改（\n字节青训营：你是？\n因为数电实验的队友是一个非常认真的人，我也不好意思划水，（被迫）学了好多我压根没打算学的东西，还挺感谢他的。我其实是一个很需要被人push的人，不然就很容易摆烂。\n其他\n沉迷了两天失落城堡，打通了二周目，好玩。\n因为不想碰其他娱乐，比如知乎，b站，X，reddit（其实还是没有完全不碰）。这两周只能高强度看动漫了：游戏人生，双城之战一&amp;二，比宇宙更远的地方 都给看了，都是很不错的作品，补旧番的好处就是不用突然被喂史，只看好评如潮的就行了。后续计划看少歌，轻音，京吹几部剧场版，终末少女，奇巧计程车这些。\n","categories":["周记"]},{"title":"周记(六)","url":"/posts/bf6eaed4.html","content":"这周还蛮摆的。\nCS\njava web基本学完了，做了个小案例，感觉稍微学到点东西吧。\n计网那本书看完了自己感兴趣的，又买了本tcp/ip准备深入一下。\n计组稍微看了一点，主要是复习了之前学到的。\nleetcode基本没写。\n之前打算的字节青训营基本也是摆了，实在是抽不出学java的精力去学go。\n还看了不少面经。\n目前其实有一个很大的问题就是知识不成体系，比如多线程和锁这块反复看还是联系不起来，我觉得原因一是目前基本没怎么用过多线程，现在看来看去也是空中楼阁，二是懒得记笔记，导致学过的还要反复去看。学的太散，还是要坚持写博客。\n根据面经还是能感觉到自己还有很多不熟悉的，接下来会把重点放到SSM,SpringBoot,MySql这三个部分。然后就是继续写个项目吧，还是得写一下多线程。\n其他\n这周没有继续用那个时间记录软件了，因为用的我不太自在，很难描述这种感觉，我不太喜欢把自己当机器，这样我很容易给自己上压力。然而todo就跟不上了，学校这周又很忙，这也是导致这周摆的原因之一吧。\n做实验课和别人“狠狠的”交流了，基本满足了我这周的社交需求。\n有天晚上上完课在下雨，我没带伞，不过我还挺喜欢淋着雨走的。走了一段时间后一个女生突然过来默默的给我打伞，还送我到了寝室楼下，为什么呢？我已经很久没有接受过这种善意了。我感谢她，虽然我除了谢谢也没办法为她做什么。可我并没有什么情绪起伏，为什么呢？因为长时间的孤独我又丧失了一种感情吗？我真不想这样。\n最近外面不太平呢，准备出去玩的计划也搁置了。和妈妈联系了一下，看到别人的家庭如何如何就会很害怕这种事情发生在自己身边，所以决定以后尽量让自己不去接触这些信息。\n最近思想又很容易变得极端，已经在尽力遏制了，减少信息的来源是我最需要做的。\n祝好。\n","categories":["周记"]},{"title":"周记（十一）","url":"/posts/b690e20.html","content":"周一\n✅ SpringMVC拦截器，异常处理，数据校验\n✅ Knife4j\n周二\n✅ Mybatis参数处理，关联查询\n✅ 算法题\n✅《精力管理》53%\n周三\n✅ 算法题\n周四\n✅ MybatisPlus\n✅ 算法题\n✅《精力管理》100%\n✅《隐形守护者》完结\n✅ 跑步\n周五\n✅ 动态SQL\n✅ 算法\n✅ MybatisX和分页插件\n✅《我的第一本算法书》43%\n✅ 《深入理解Java虚拟机》12%\n周六周日\n生病躺尸\n总结\n本周基本把项目需要的知识点重新过了一遍，下周就安心做项目了。\n这周也是刷了几天算法，好难，大概就是15-30分钟一道题这样，属于是很难利用起碎片时间但又实在是抽不出大块时间专门去做，卡在这了。\n好久没写技术类博客了，下周想看看有什么东西能写吧，这周学的SSM全是应用相关的，脱离代码就没什么好说的了，至于JVM和JUC目前还是没什么好的学习办法，学了就忘。/_ \n接下来的计划根据项目的速度来吧，如果比较快的话就分给算法和面经一部分时间，如果慢的话就专心项目。\n因为有校园跑的压力在，所以这学期我从这周就开始跑了，每次大概2-3公里，过几周应该会稳定在上学期的四公里。\n有些时候我会觉得该放松一下了，但是大概率会过度放松，下周尝试去改变一下放松的方式，比如听播客什么的。\n另外就是，这周选择每过一天就在周记里写点东西，以便回顾今天干了什么，目前感觉还不错。\n","categories":["周记"]},{"title":"周记（十二）","url":"/posts/3b7fe2f8.html","content":"周一\n✅ 项目 55%\n周二\n项目\n算法\n","categories":["周记"]},{"title":"年终总结","url":"/posts/1f18a9aa.html","content":"想了想还是写个年终总结吧。\n我在24年初写过一份2024年规划，但是不知何时那个文件丢失了，现在也只依稀记得几项了，唯一可以确定的是基本一个都没有完成。\n今年是我第一次在大学完整的度过一年。\n上半年我对自己的未来很有信心，甚至到了自大的地步，尤其在我三月份学完了大部分CSAPP后到达了愚昧之峰。现在想想那时我也没学到什么东西， 语言，算法，体系结构都是浅尝辄止，除此之外似乎也没什么值得一提的了。而当时的我却以为自己已经俯瞰了整个计算机世界，一切唾手可得，那接下来的当然是绝望之谷。\n\n四五月份的打击接踵而来，如今我已无心分辨对错，而当时的我，的确是陷入了深深的自我否定之中。消沉了一段时间后强打精神学了Hadoop之类，当然没什么收获，现在我已经记不得到底学了什么，为数不多的印象全是在配环境。\n草草应付完期末后我回到了家，在亲情的温暖下我多少找到了一些力量。妈妈出于对我的关心，给我找了一份暑假工，希望让我多与人接触。\n不得不说，打工那一个月是我今年最快乐的时间，没有太多的深谋远虑，只需要认真做好眼前的事情，与人们的交流也让我感到轻松。其实每天早八晚五的工作对我来说还挺累的，但我所做的一切都是有意义的，我写的每一个字，说的每一句话都会对某一个人产生或大或小的影响。这是在理论学习中感受不到的“活着”的感觉。\n这个过程中也慢慢接纳了真正的自己，开始像一个普通的计算机学生一样认真从CS61A学起。\n八月份结束工作后又学习了一部分61A就要准备开学了。\n开学后的那段时间我是相当有能量的，九月份完成了61A和部分考试，十一月中旬完成了61B。\n下一步不知道自己要学什么了，开始随便看看一些Java知识，后来去学了一下SSM和SpringBoot。之后便开始了边摸鱼边复习期末的日子。\n回过头来却发现这一年已经结束了，得到了之前梦想的自由与时间后我并没有什么成就。\n今年大概是我的价值观与现实冲突最剧烈的一年了，4–7月这段时间每天都在自我挣扎，不过最终还是选择了和解，心态也趋于平和。\n今年我依旧会写新年规划，这次我会尽力保证它不丢失。\n新的一年，祝好。\n"},{"title":"效率&时间","url":"/posts/797198ce.html","content":"总想用效率取胜，却忽略了没有足够的时间堆砌，再高的效率也是没用的。有人说已经来不及了，有人说还早着呢，我是怎么想的呢？我也不知道。\n有些事情是我能够改变的，但由于我的自暴自弃还是错过了，在“我其实没那么差”和“我其实没那么好”中反复撕扯自己。\n安安心心的付出时间。\n","categories":["随想"]},{"title":"日々早八，日々早八","url":"/posts/afafbad8.html","content":"由于平时和室友基本都是12点左右上床熄灯，而我又要在床上写写总结，逛逛b站，经常导致我基本是1点左右睡着。\n其实这学期是有四天早八的，两个可以翘掉，便是剩下两节英语课，每周也就两节课而已。英语！一个在大学基本无法从课堂上学到任何东西的学科，开课究竟有什么意义呢？\n虽说每周英语课不多，英语老师却大多不好应付，他们似乎并不觉得自己的存在有些多余，反而会节节考勤，频繁提问，以表现出一幅勃勃生机的课堂画面。而只睡了六个小时的我只能在学又学不进去，睡又睡不着的情况下被折磨两个小时。每次尝试看专业书大脑便会一直和眼睛谈判，直到我放弃。\n由于大脑和身体都极度疲惫，只能逛逛博客，网上到处转转。而如果不用咖啡续命的话，这个状态会持续一整天，可是我经常忘记喝orz。\n今天直到现在也是头晕晕的。\n好了，我去喝咖啡了。\n\n","categories":["随想"]},{"title":"滑动窗口","url":"/posts/50cab45.html","content":"简介\n滑动窗口算法主要用于解决某个符合条件的最短/最长数组，是双指针技巧中的一种\n如果使用暴力解法的话是这样：\nfor (int i = 0; i &lt; nums.length; i++) {    for (int j = i; j &lt; nums.length; j++) {        // nums[i, j] 是一个子数组    }}\n遍历每个子数组从而找到符合条件的数组。滑动窗口就是对这个方法的改善。\n我们使用一左一右两个指针来维护一个窗口，然后不断滑动，在滑动的过程中去更新答案。\n代码模板如下：\n// 滑动窗口算法伪码框架void slidingWindow(String s) {    // 用合适的数据结构记录窗口中的数据，根据具体场景变通    // 比如说，我想记录窗口中元素出现的次数，就用 map    // 如果我想记录窗口中的元素和，就可以只用一个 int    Object window = ...        int left = 0, right = 0;    while (right &lt; s.length()) {        // c 是将移入窗口的字符        char c = s[right];        window.add(c)        // 增大窗口        right++;        // 进行窗口内数据的一系列更新        ...        // 判断左侧窗口是否要收缩        while (left &lt; right &amp;&amp; window needs shrink) {            // d 是将移出窗口的字符            char d = s[left];            window.remove(d)            // 缩小窗口            left++;            // 进行窗口内数据的一系列更新            ...        }    }}\n我们通过不断移动right指针扩大窗口，用来寻找符合条件的子串，找到这个字串后，我们再去移动left指针来缩小窗口，缩小窗口就是去优化我们找到的这个字串。当然，这是去寻找最短的思路，具体的目的根据我们更新窗口的操作来决定，还有什么时候更新答案也是根据具体的要求。\nEX.最小覆盖字串\n给你一个字符串&nbsp;s&nbsp;、一个字符串&nbsp;t&nbsp;。返回&nbsp;s&nbsp;中涵盖&nbsp;t&nbsp;所有字符的最小子串。如果&nbsp;s&nbsp;中不存在涵盖&nbsp;t&nbsp;所有字符的子串，则返回空字符串&nbsp;\"\"&nbsp;。\n我们利用哈希表来判断我们的窗口是否满足了条件，如果字符出现的次数相同，那么就是满足了条件。一个哈希表表示我们需要满足的目标，另一个哈希表表示我们目前的进度。\n每满足一个字符的要求我们就把valid++，当valid的大小等于need的大小时，我们就满足了所有字符的要求。\n之后我们就需要去优化我们找到的这个字串，看它还能不能更短。\n当right到达最右边时窗口的大小就无法再增加了，这时就返回我们的结果。\nclass Solution {    public String minWindow(String s, String t) {        Map&lt;Character, Integer&gt; need = new HashMap&lt;&gt;();        Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();        for (char c : t.toCharArray()) {            need.put(c, need.getOrDefault(c, 0) + 1);        }        int left = 0, right = 0;        int valid = 0;        // 记录最小覆盖子串的起始索引及长度        int start = 0, len = Integer.MAX_VALUE;        while (right &lt; s.length()) {            // c 是将移入窗口的字符            char c = s.charAt(right);            // 扩大窗口            right++;            // 进行窗口内数据的一系列更新            if (need.containsKey(c)) {                window.put(c, window.getOrDefault(c, 0) + 1);                if (window.get(c).equals(need.get(c)))                    valid++;            }            // 判断左侧窗口是否要收缩            while (valid == need.size()) {                // 在这里更新最小覆盖子串                if (right - left &lt; len) {                    start = left;                    len = right - left;                }                // d 是将移出窗口的字符                char d = s.charAt(left);                // 缩小窗口                left++;                // 进行窗口内数据的一系列更新                if (need.containsKey(d)) {                    if (window.get(d).equals(need.get(d)))                        valid--;                    window.put(d, window.get(d) - 1);                }                                }        }        // 返回最小覆盖子串        return len == Integer.MAX_VALUE ? \"\" : s.substring(start, start + len);    }}","categories":["学习笔记"],"tags":["算法"]}]